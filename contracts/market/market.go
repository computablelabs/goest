// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package market

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// MarketABI is the input ABI used to generate the binding from.
const MarketABI = "[{\"name\":\"ApplicationFailed\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Applied\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true},{\"type\":\"address\",\"name\":\"applicant\",\"indexed\":true},{\"type\":\"bytes32\",\"name\":\"dataHash\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Challenged\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true},{\"type\":\"address\",\"name\":\"challenger\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ChallengeFailed\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true},{\"type\":\"address\",\"name\":\"challenger\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"reward\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ChallengeSucceeded\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true},{\"type\":\"address\",\"name\":\"challenger\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"reward\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Divested\",\"inputs\":[{\"type\":\"address\",\"name\":\"investor\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"transferred\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Invested\",\"inputs\":[{\"type\":\"address\",\"name\":\"investor\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"offered\",\"indexed\":false,\"unit\":\"wei\"},{\"type\":\"uint256\",\"name\":\"minted\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Listed\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true},{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"reward\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingConverted\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingDeposit\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true},{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"deposited\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingRemoved\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingWithdraw\",\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\",\"indexed\":true},{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"withdrawn\",\"indexed\":false,\"unit\":\"wei\"}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"ether_token_address\"},{\"type\":\"address\",\"name\":\"market_token_address\"},{\"type\":\"address\",\"name\":\"voting_address\"},{\"type\":\"address\",\"name\":\"parameterizer_address\"}],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"name\":\"isListed\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":700},{\"name\":\"isListing\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1033},{\"name\":\"wasListing\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":754},{\"name\":\"isListingOwner\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":758},{\"name\":\"isInvestor\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1162},{\"name\":\"depositToListing\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"},{\"type\":\"uint256\",\"name\":\"amount\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":42961},{\"name\":\"withdrawFromListing\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"},{\"type\":\"uint256\",\"name\":\"amount\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":43260},{\"name\":\"list\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"listing\"},{\"type\":\"bytes32\",\"name\":\"data_hash\"},{\"type\":\"uint256\",\"name\":\"amount\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":261510},{\"name\":\"getListingCount\",\"outputs\":[{\"type\":\"int128\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":723},{\"name\":\"getListingKey\",\"outputs\":[{\"type\":\"bytes32\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"int128\",\"name\":\"index\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":970},{\"name\":\"getListing\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"},{\"type\":\"address\",\"name\":\"out\"},{\"type\":\"bytes32\",\"name\":\"out\"},{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"},{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2689},{\"name\":\"convertListing\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":83276},{\"name\":\"resolveApplication\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":287835},{\"name\":\"challenge\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"chall\"},{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":48080},{\"name\":\"getChallenge\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1066},{\"name\":\"resolveChallenge\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":372182},{\"name\":\"getInvested\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":993},{\"name\":\"getInvestorCount\",\"outputs\":[{\"type\":\"int128\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1023},{\"name\":\"getInvestment\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1303},{\"name\":\"getInvestmentPrice\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":12880},{\"name\":\"invest\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"offer\",\"unit\":\"wei\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":211010},{\"name\":\"getDivestmentProceeds\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\",\"unit\":\"wei\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":6650},{\"name\":\"divest\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":2443813},{\"name\":\"exit\",\"outputs\":[],\"inputs\":[{\"type\":\"bytes32\",\"name\":\"hash\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":278963}]"

// MarketBin is the compiled bytecode used for deploying new contracts.
const MarketBin = `0x600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a05260806130536101403934156100a757600080fd5b602061305360c03960c05160205181106100c057600080fd5b50602060206130530160c03960c05160205181106100dd57600080fd5b50602060406130530160c03960c05160205181106100fa57600080fd5b50602060606130530160c03960c051602051811061011757600080fd5b503360095561014051600a5561016051600b5561018051600c556101a051600d5561303b56600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a05263ecefbdc660005114156100de57602060046101403734156100b457600080fd5b6001600160006101405160e05260c052604060c02060c052602060c02001541460005260206000f3005b636aa0966b600051141561014457602060046101403734156100ff57600080fd5b6101405160006101405160e05260c052604060c02060c052602060c02054633b9aca00811061012d57600080fd5b600260c052602060c02001541460005260206000f3005b6382c3eb3e60005114156101ab576020600461014037341561016557600080fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60006101405160e05260c052604060c02060c052602060c020541460005260206000f3005b6302a47cd760005114156101fe57602060046101403734156101cc57600080fd5b60043560205181106101dd57600080fd5b50600160036101405160e05260c052604060c02054101560005260206000f3005b63cee2a9cf6000511415610276576020600461014037341561021f57600080fd5b600435602051811061023057600080fd5b506101405160046101405160e05260c052604060c02060c052602060c02054633b9aca00811061025f57600080fd5b600660c052602060c02001541460005260206000f3005b63341ff0896000511415610395576040600461014037341561029757600080fd5b60206102006024636aa0966b61018052610140516101a05261019c6000305af16102c057600080fd5b610200516102cd57600080fd5b600b543b6102da57600080fd5b600b543014156102e957600080fd5b60206102e060646323b872dd6102205233610240523061026052610160516102805261023c6000600b545af161031e57600080fd5b6000506102e050600460006101405160e05260c052604060c02060c052602060c02001805461016051825401101561035557600080fd5b61016051815401815550610160516103005233610140517f6f27446a1e23c7e7dd81a6a77f81438be78145de331a5806f2c44e68738bdcef6020610300a3005b63a7e7867560005114156104d457604060046101403734156103b657600080fd5b60206102006024636aa0966b61018052610140516101a05261019c6000305af16103df57600080fd5b610200516103ec57600080fd5b33600260006101405160e05260c052604060c02060c052602060c02001541461041457600080fd5b600460006101405160e05260c052604060c02060c052602060c02001610160518154101561044157600080fd5b61016051815403815550600b543b61045857600080fd5b600b5430141561046757600080fd5b60206102c0604463a9059cbb610220523361024052610160516102605261023c6000600b545af161049757600080fd5b6000506102c050610160516102e05233610140517f87c48f853a68e9374cf8389dab199f46adaffa48468fe9a4e2dc2edf75286db760206102e0a3005b635148cd0f60005114156107d857606060046101403734156104f557600080fd5b60606004356004016101a037604060043560040135111561051557600080fd5b60206102a0602463cee2a9cf61022052336102405261023c6000305af161053b57600080fd5b6102a0511561054957600080fd5b6101a08051602082012090506102c052600c543b61056657600080fd5b600c5430141561057557600080fd5b60206103606024631f1b02996102e0526102c051610300526102fc600c545afa61059e57600080fd5b600050610360516105ae57600080fd5b600c543b6105bb57600080fd5b600c543014156105ca57600080fd5b600060006064637ff45d8b610400526102c05161042052600161044052600d543b6105f457600080fd5b600d5430141561060357600080fd5b60206103e06004632d0d2bc66103805261039c600d545afa61062457600080fd5b6000506103e0516104605261041c6000600c545af161064257600080fd5b33600260006102c05160e05260c052604060c02060c052602060c020015561016051600360006102c05160e05260c052604060c02060c052602060c020015560015460006102c05160e05260c052604060c02060c052602060c020556102c051600154633b9aca0081106106b557600080fd5b600260c052602060c020015560016060516001825401806040519013156106db57600080fd5b80919012156106e957600080fd5b81555060033360e05260c052604060c02080546001825401101561070c57600080fd5b6001815401815550600061018051111561079a57600b543b61072d57600080fd5b600b5430141561073c57600080fd5b602061058060646323b872dd6104c052336104e052306105005261018051610520526104dc6000600b545af161077157600080fd5b6000506105805061018051600460006102c05160e05260c052604060c02060c052602060c02001555b610160516105a052610180516105c052336102c0517f2be7f407f8117561d2a0100982c56a4a1ec8ffc24bbeb7b087b2ca8a224cc56d60406105a0a3005b6387ed92d760005114156107fe5734156107f157600080fd5b60015460005260206000f3005b63c48dc1af600051141561086e576020600461014037341561081f57600080fd5b6060516004358060405190131561083557600080fd5b809190121561084357600080fd5b5061014051633b9aca00811061085857600080fd5b600260c052602060c020015460005260206000f3005b63175c0d16600051141561094a576020600461014037341561088f57600080fd5b60a061016052610180600160006101405160e05260c052604060c02060c052602060c02001548152600260006101405160e05260c052604060c02060c052602060c02001548160200152600360006101405160e05260c052604060c02060c052602060c02001548160400152600460006101405160e05260c052604060c02060c052602060c02001548160600152600560006101405160e05260c052604060c02060c052602060c020015481608001525061016051610180f3005b63d748484d6000511415610b62576020600461014037341561096b57600080fd5b6001600160006101405160e05260c052604060c02060c052602060c02001541461099457600080fd5b33600260006101405160e05260c052604060c02060c052602060c0200154146109bc57600080fd5b600460006101405160e05260c052604060c02060c052602060c0200154600560006101405160e05260c052604060c02060c052602060c0200154600460006101405160e05260c052604060c02060c052602060c0200154011015610a1f57600080fd5b600560006101405160e05260c052604060c02060c052602060c0200154600460006101405160e05260c052604060c02060c052602060c020015401610160526000610160511115610b17576000600460006101405160e05260c052604060c02060c052602060c02001556000600560006101405160e05260c052604060c02060c052602060c0200155600b543b610ab557600080fd5b600b54301415610ac457600080fd5b6020610220604463a9059cbb61018052600260006101405160e05260c052604060c02060c052602060c02001546101a052610160516101c05261019c6000600b545af1610b1057600080fd5b6000506102205b5030600260006101405160e05260c052604060c02060c052602060c0200155610140517ffd6a9ca1840ac9f8b7c592783e5415fdc282281630286c93b07b6d40f3c0ba5760006000a2005b600015610f78575b610160526101405260206102006024636aa0966b61018052610140516101a05261019c6000305af1610b9b57600080fd5b61020051610ba857600080fd5b6000600460006101405160e05260c052604060c02060c052602060c02001541115610c7557600b543b610bda57600080fd5b600b54301415610be957600080fd5b60206102c0604463a9059cbb61022052600260006101405160e05260c052604060c02060c052602060c020015461024052600460006101405160e05260c052604060c02060c052602060c02001546102605261023c6000600b545af1610c4e57600080fd5b6000506102c0506000600460006101405160e05260c052604060c02060c052602060c02001555b6000600560006101405160e05260c052604060c02060c052602060c02001541115610d1957600b543b610ca757600080fd5b600b54301415610cb657600080fd5b6000600060246342966c686102e052600560006101405160e05260c052604060c02060c052602060c0200154610300526102fc6000600b545af1610cf957600080fd5b6000600560006101405160e05260c052604060c02060c052602060c02001555b6001606051600182540380604051901315610d3357600080fd5b8091901215610d4157600080fd5b81555060006001541315610dd35760006101405160e05260c052604060c02060c052602060c0205461036052600154633b9aca008110610d8057600080fd5b600260c052602060c0200154610380526103805161036051633b9aca008110610da857600080fd5b600260c052602060c02001556103605160006103805160e05260c052604060c02060c052602060c020555b6000600154633b9aca008110610de857600080fd5b600260c052602060c02001556003600260006101405160e05260c052604060c02060c052602060c020015460e05260c052604060c020600181541015610e2d57600080fd5b600181540381555060016003600260006101405160e05260c052604060c02060c052602060c020015460e05260c052604060c020541015610ec857600c543b610e7557600080fd5b600c54301415610e8457600080fd5b60006000602463335d80806103a052600260006101405160e05260c052604060c02060c052602060c02001546103c0526103bc6000600c545af1610ec757600080fd5b5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60006101405160e05260c052604060c02060c052602060c020556001600160006101405160e05260c052604060c02060c052602060c02001541415610f48576000600160006101405160e05260c052604060c02060c052602060c02001555b610140517f50425cae216bd151d26c8e8bb9779cc899c99d72f78081f2ceec9a99f001ff7960006000a261016051565b6318e28e1c600051141561143d5760206004610140373415610f9957600080fd5b600c543b610fa657600080fd5b600c54301415610fb557600080fd5b60206101e060246362f9a55d61016052336101805261017c600c545afa610fdb57600080fd5b6000506101e051610feb57600080fd5b600c543b610ff857600080fd5b600c5430141561100757600080fd5b60206102a0604463af61f76061020052610140516102205260016102405261021c600c545afa61103657600080fd5b6000506102a05161104657600080fd5b6001600160006101405160e05260c052604060c02060c052602060c0200154141561107057600080fd5b600c543b61107d57600080fd5b600c5430141561108c57600080fd5b6020610340602463327322c86102c052610140516102e0526102dc600c545afa6110b557600080fd5b600050610340516110c557600080fd5b600c543b6110d257600080fd5b600c543014156110e157600080fd5b60206105006044638f354b79610460526101405161048052600d543b61110657600080fd5b600d5430141561111557600080fd5b6020610440600463c26c12eb6103e0526103fc600d545afa61113657600080fd5b600050610440516104a05261047c600c545afa61115257600080fd5b600050610500511561134b576001600160006101405160e05260c052604060c02060c052602060c0200155600d543b61118a57600080fd5b600d5430141561119957600080fd5b60206105a0600463dc2b28536105405261055c600d545afa6111ba57600080fd5b6000506105a05161052052600b543b6111d257600080fd5b600b543014156111e157600080fd5b60006000602463a0712d686105c052610520516105e0526105dc6000600b545af161120b57600080fd5b61052051600560006101405160e05260c052604060c02060c052602060c0200155600c543b61123957600080fd5b600c5430141561124857600080fd5b60206106c0602463c666b58061064052600260006101405160e05260c052604060c02060c052602060c02001546106605261065c600c545afa61128a57600080fd5b6000506106c051156112f657600c543b6112a357600080fd5b600c543014156112b257600080fd5b60006000602463471bb3096106e052600260006101405160e05260c052604060c02060c052602060c0200154610700526106fc6000600c545af16112f557600080fd5b5b6105205161076052600260006101405160e05260c052604060c02060c052602060c0200154610140517f7f1a2c3e2883554425dc0f9f24dcfcdf54213b186c550080373dcc65813aa8d06020610760a36113f5565b6101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405163550ee1336103605261014051610380526103805160065801610b6a565b6103405261032052610300526102e0526102c0526102a05261028052610260526102405261022052610200526101e0526101c0526101a0526101805261016052610140526000505b600c543b61140257600080fd5b600c5430141561141157600080fd5b6000600060246389bb617c61078052610140516107a05261079c6000600c545af161143b57600080fd5b005b63cd32dcc5600051141561167d576040600461014037341561145e57600080fd5b606060043560040161018037604060043560040135111561147e57600080fd5b600160006101605160e05260c052604060c02060c052602060c02001546114a457600080fd5b600d543b6114b157600080fd5b600d543014156114c057600080fd5b60206102806004635aebe7686102205261023c600d545afa6114e157600080fd5b60005061028051610200526101808051602082012090506102a052600c543b61150957600080fd5b600c5430141561151857600080fd5b60206103406024631f1b02996102c0526102a0516102e0526102dc600c545afa61154157600080fd5b6000506103405161155157600080fd5b600b543b61155e57600080fd5b600b5430141561156d57600080fd5b602061042060646323b872dd610360523361038052306103a052610200516103c05261037c6000600b545af16115a257600080fd5b600050610420503360086101605160e05260c052604060c02055600c543b6115c957600080fd5b600c543014156115d857600080fd5b600060006064637ff45d8b6104c052610160516104e052600261050052600d543b61160257600080fd5b600d5430141561161157600080fd5b60206104a06004632d0d2bc66104405261045c600d545afa61163257600080fd5b6000506104a051610520526104dc6000600c545af161165057600080fd5b33610160517fe9479421670c3425a1497ce47a53af8bd96ce5bd0741e96221ba0acace3f7d4760006000a3005b63458d2bf160005114156116ba576020600461014037341561169e57600080fd5b60086101405160e05260c052604060c0205460005260206000f3005b63d32c943a6000511415611eed57602060046101403734156116db57600080fd5b600c543b6116e857600080fd5b600c543014156116f757600080fd5b60206101e060246362f9a55d61016052336101805261017c600c545afa61171d57600080fd5b6000506101e05161172d57600080fd5b600c543b61173a57600080fd5b600c5430141561174957600080fd5b60206102a0604463af61f76061020052610140516102205260026102405261021c600c545afa61177857600080fd5b6000506102a05161178857600080fd5b600c543b61179557600080fd5b600c543014156117a457600080fd5b6020610340602463327322c86102c052610140516102e0526102dc600c545afa6117cd57600080fd5b600050610340516117dd57600080fd5b600d543b6117ea57600080fd5b600d543014156117f957600080fd5b60206103e06004635aebe7686103805261039c600d545afa61181a57600080fd5b6000506103e05161036052600460006101405160e05260c052604060c02060c052602060c020015461040052600560006101405160e05260c052604060c02060c052602060c0200154610420526103605161040051610420516104005101101561188357600080fd5b6104205161040051011015611a615760006104005161042051610400510110156118ac57600080fd5b610420516104005101111561197a576000600460006101405160e05260c052604060c02060c052602060c02001556000600560006101405160e05260c052604060c02060c052602060c0200155600b543b61190657600080fd5b600b5430141561191557600080fd5b6020610820604463a9059cbb6107805260086101405160e05260c052604060c020546107a05261040051610420516104005101101561195357600080fd5b6104205161040051016107c05261079c6000600b545af161197357600080fd5b6000506108205b506101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a0516103c0516103e051610400516104205163550ee1336108405261014051610860526108605160065801610b6a565b61042052610400526103e0526103c0526103a05261038052610360526103405261032052610300526102e0526102c0526102a05261028052610260526102405261022052610200526101e0526101c0526101a052610180526101605261014052600050611eeb565b600c543b611a6e57600080fd5b600c54301415611a7d57600080fd5b60206105806044638f354b796104e0526101405161050052600d543b611aa257600080fd5b600d54301415611ab157600080fd5b60206104c0600463c26c12eb6104605261047c600d545afa611ad257600080fd5b6000506104c051610520526104fc600c545afa611aee57600080fd5b6000506105805115611e10576103605161040051101515611b4557600460006101405160e05260c052604060c02060c052602060c020016103605181541015611b3657600080fd5b61036051815403815550611bcc565b6000600460006101405160e05260c052604060c02060c052602060c0200155600560006101405160e05260c052604060c02060c052602060c0200161040051610360511015611b9357600080fd5b61040051610360510381541015611ba957600080fd5b61040051610360511015611bbc57600080fd5b6104005161036051038154038155505b600b543b611bd957600080fd5b600b54301415611be857600080fd5b6020610640604463a9059cbb6105a05260086101405160e05260c052604060c020546105c052610360511515611c1f576000611c3f565b600261036051600261036051020414611c3757600080fd5b600261036051025b6105e0526105bc6000600b545af1611c5657600080fd5b600050610640506101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a0516103c0516103e05161040051610420516104405161046051610480516104a0516104c0516104e05161050051610520516105405161056051610580516105a0516105c0516105e05161060051610620516106405163550ee1336106605261014051610680526106805160065801610b6a565b6106405261062052610600526105e0526105c0526105a05261058052610560526105405261052052610500526104e0526104c0526104a05261048052610460526104405261042052610400526103e0526103c0526103a05261038052610360526103405261032052610300526102e0526102c0526102a05261028052610260526102405261022052610200526101e0526101c0526101a052610180526101605261014052600050610360516106e05260086101405160e05260c052604060c02054610140517fb2432a6d7681dc3f7416efc0e321723b96bd7a96d2d02d228dc2a67c51cf032260206106e0a3611e90565b600560006101405160e05260c052604060c02060c052602060c020018054610360518254011015611e4057600080fd5b61036051815401815550610360516104405260086101405160e05260c052604060c02054610140517fc7aab91fe7b50a881bd71df2cf07e9a6e5351721087cdb09bc70603f618e70576020610440a35b600060086101405160e05260c052604060c02055600c543b611eb157600080fd5b600c54301415611ec057600080fd5b6000600060246389bb617c61070052610140516107205261071c6000600c545af1611eea57600080fd5b5b005b63befc3e2b6000511415611f13573415611f0657600080fd5b60075460005260206000f3005b63960524e36000511415611f39573415611f2c57600080fd5b60055460005260206000f3005b63146b58df6000511415611f935760206004610140373415611f5a57600080fd5b6004356020518110611f6b57600080fd5b50600160046101405160e05260c052604060c02060c052602060c020015460005260206000f3005b63a3d6602b600051141561251c573415611fac57600080fd5b600d543b611fb957600080fd5b600d54301415611fc857600080fd5b60206101c0600463f36089ec6101605261017c600d545afa611fe957600080fd5b6000506101c05161014052600d543b61200157600080fd5b600d5430141561201057600080fd5b60206102606004634ba135d86102005261021c600d545afa61203157600080fd5b600050610260516101e052600d543b61204957600080fd5b600d5430141561205857600080fd5b602061030060046328dee5706102a0526102bc600d545afa61207957600080fd5b6000506103005161028052600a543b61209157600080fd5b600a543014156120a057600080fd5b60206103c060246370a0823161034052306103605261035c600a545afa6120c657600080fd5b6000506103c05161032052600b543b6120de57600080fd5b600b543014156120ed57600080fd5b602061046060046318160ddd6104005261041c600b545afa61210e57600080fd5b600050610460516103e052670de0b6b3a76400006103e05110156121e457610140516101e05161213d57600080fd5b6101e051610280511515612152576000612178565b6103205161028051610320516102805102041461216e57600080fd5b6103205161028051025b046101405101101561218957600080fd5b6101e05161219657600080fd5b6101e0516102805115156121ab5760006121d1565b610320516102805161032051610280510204146121c757600080fd5b6103205161028051025b04610140510160005260206000f361251a565b610140516101e05115156121f957600061221f565b6103e0516101e0516103e0516101e05102041461221557600080fd5b6103e0516101e051025b61222857600080fd5b6101e051151561223957600061225f565b6103e0516101e0516103e0516101e05102041461225557600080fd5b6103e0516101e051025b610280511515612270576000612296565b6103205161028051610320516102805102041461228c57600080fd5b6103205161028051025b15156122a3576000612371565b670de0b6b3a76400006102805115156122bd5760006122e3565b610320516102805161032051610280510204146122d957600080fd5b6103205161028051025b670de0b6b3a76400006102805115156122fd576000612323565b6103205161028051610320516102805102041461231957600080fd5b6103205161028051025b02041461232f57600080fd5b670de0b6b3a764000061028051151561234957600061236f565b6103205161028051610320516102805102041461236557600080fd5b6103205161028051025b025b046101405101101561238257600080fd5b6101e05115156123935760006123b9565b6103e0516101e0516103e0516101e0510204146123af57600080fd5b6103e0516101e051025b6123c257600080fd5b6101e05115156123d35760006123f9565b6103e0516101e0516103e0516101e0510204146123ef57600080fd5b6103e0516101e051025b61028051151561240a576000612430565b6103205161028051610320516102805102041461242657600080fd5b6103205161028051025b151561243d57600061250b565b670de0b6b3a764000061028051151561245757600061247d565b6103205161028051610320516102805102041461247357600080fd5b6103205161028051025b670de0b6b3a76400006102805115156124975760006124bd565b610320516102805161032051610280510204146124b357600080fd5b6103205161028051025b0204146124c957600080fd5b670de0b6b3a76400006102805115156124e3576000612509565b610320516102805161032051610280510204146124ff57600080fd5b6103205161028051025b025b04610140510160005260206000f35b005b632afcf48060005114156128dd576020600461014037341561253d57600080fd5b60206101e060246302a47cd761016052336101805261017c6000305af161256357600080fd5b6101e0511561257157600080fd5b6020610280600463a3d6602b6102205261023c6000305af161259257600080fd5b6102805161020052610200516101405110156125ad57600080fd5b600a543b6125ba57600080fd5b600a543014156125c957600080fd5b602061036060646323b872dd6102a052336102c052306102e05261014051610300526102bc6000600a545af16125fe57600080fd5b600050610360506102005161261257600080fd5b6102005161014051041515612628576000612687565b633b9aca006102005161263a57600080fd5b610200516101405104633b9aca006102005161265557600080fd5b61020051610140510402041461266a57600080fd5b633b9aca006102005161267c57600080fd5b610200516101405104025b61038052600b543b61269857600080fd5b600b543014156126a757600080fd5b60006000602463a0712d686103a052610380516103c0526103bc6000600b545af16126d157600080fd5b600b543b6126de57600080fd5b600b543014156126ed57600080fd5b60206104c0604463a9059cbb610420523361044052610380516104605261043c6000600b545af161271d57600080fd5b6000506104c0506020610560602463cee2a9cf6104e05233610500526104fc6000305af161274a57600080fd5b61056051151561284c5760055460043360e05260c052604060c02060c052602060c0205533600554633b9aca00811061278257600080fd5b600660c052602060c020015560056060516001825401806040519013156127a857600080fd5b80919012156127b657600080fd5b815550600c543b6127c657600080fd5b600c543014156127d557600080fd5b6020610600602463c666b58061058052336105a05261059c600c545afa6127fb57600080fd5b600050610600511561284b57600c543b61281457600080fd5b600c5430141561282357600080fd5b60006000602463471bb30961062052336106405261063c6000600c545af161284a57600080fd5b5b5b600160043360e05260c052604060c02060c052602060c02001805461014051825401101561287957600080fd5b610140518154018155506007805461014051825401101561289957600080fd5b61014051815401815550610140516106a052610380516106c052337f9e9d071824fd57d062ca63fd8b786d8da48a6807eebbcb2d83f9e8d21398e28c60406106a0a2005b63998339036000511415612a5957602060046101403734156128fe57600080fd5b600435602051811061290f57600080fd5b50600061014051141561292157600080fd5b600b543b61292e57600080fd5b600b5430141561293d57600080fd5b602061020060246370a0823161018052610140516101a05261019c600b545afa61296657600080fd5b6000506102005161016052600a543b61297e57600080fd5b600a5430141561298d57600080fd5b60206102c060246370a0823161024052306102605261025c600a545afa6129b357600080fd5b6000506102c05161022052600b543b6129cb57600080fd5b600b543014156129da57600080fd5b602061036060046318160ddd6103005261031c600b545afa6129fb57600080fd5b600050610360516102e0526102e051612a1357600080fd5b6102e051610160511515612a28576000612a4e565b61022051610160516102205161016051020414612a4457600080fd5b6102205161016051025b0460005260206000f3005b63058aace16000511415612ddd573415612a7257600080fd5b600061014052600c543b612a8557600080fd5b600c54301415612a9457600080fd5b60206101e060046330a563476101805261019c600c545afa612ab557600080fd5b6000506101e0516101605261020060006103e8818352015b600c543b612ada57600080fd5b600c54301415612ae957600080fd5b60206102c060246379b7392461024052610200516102605261025c600c545afa612b1257600080fd5b6000506102c0516102205261016051610200511415612b3457612b6a56612b59565b3360086102205160e05260c052604060c020541415612b5857600161014052612b6a565b5b5b8151600101808352811415612acd575b50506101405115612b7a57600080fd5b60206103806024639983390361030052336103205261031c6000305af1612ba057600080fd5b610380516102e052600b543b612bb557600080fd5b600b54301415612bc457600080fd5b600060006024637e9d2ac16103a052336103c0526103bc6000600b545af1612beb57600080fd5b60206104a0602463cee2a9cf61042052336104405261043c6000305af1612c1157600080fd5b6104a05115612d58576005606051600182540380604051901315612c3457600080fd5b8091901215612c4257600080fd5b81555060006005541315612d365760043360e05260c052604060c02060c052602060c020546104c052600554633b9aca008110612c7e57600080fd5b600660c052602060c02001546104e0526104e0516104c051633b9aca008110612ca657600080fd5b600660c052602060c02001556104c05160046104e05160e05260c052604060c02060c052602060c0205560043360e05260c052604060c02060c052602060c020600081556000600182015550600c543b612cff57600080fd5b600c54301415612d0e57600080fd5b60006000602463335d808061050052336105205261051c6000600c545af1612d3557600080fd5b5b6000600554633b9aca008110612d4b57600080fd5b600660c052602060c02001555b600a543b612d6557600080fd5b600a54301415612d7457600080fd5b6020610620604463a9059cbb61058052336105a0526102e0516105c05261059c6000600a545af1612da457600080fd5b600050610620506102e05161064052337f2253aebe2fe8682635bbe60d9b78df72efaf785a596910a8ad66e8c6e37584fd6020610640a2005b630ca362636000511415612ef85760206004610140373415612dfe57600080fd5b33600260006101405160e05260c052604060c02060c052602060c020015414612e2657600080fd5b6001600160006101405160e05260c052604060c02060c052602060c020015414612e4f57600080fd5b600c543b612e5c57600080fd5b600c54301415612e6b57600080fd5b60206101e0602463b89694c661016052610140516101805261017c600c545afa612e9457600080fd5b6000506101e05115612ea557600080fd5b6101405161016051610180516101a0516101c0516101e05163550ee1336102005261014051610220526102205160065801610b6a565b6101e0526101c0526101a052610180526101605261014052600050005b60006000fd5b61013d61303b0361013d60003961013d61303b036000f3`

// DeployMarket deploys a new Ethereum contract, binding an instance of Market to it.
func DeployMarket(auth *bind.TransactOpts, backend bind.ContractBackend, ether_token_address common.Address, market_token_address common.Address, voting_address common.Address, parameterizer_address common.Address) (common.Address, *types.Transaction, *Market, error) {
	parsed, err := abi.JSON(strings.NewReader(MarketABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(MarketBin), backend, ether_token_address, market_token_address, voting_address, parameterizer_address)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Market{MarketCaller: MarketCaller{contract: contract}, MarketTransactor: MarketTransactor{contract: contract}, MarketFilterer: MarketFilterer{contract: contract}}, nil
}

// Market is an auto generated Go binding around an Ethereum contract.
type Market struct {
	MarketCaller     // Read-only binding to the contract
	MarketTransactor // Write-only binding to the contract
	MarketFilterer   // Log filterer for contract events
}

// MarketCaller is an auto generated read-only Go binding around an Ethereum contract.
type MarketCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MarketTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MarketTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MarketFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MarketFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MarketSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MarketSession struct {
	Contract     *Market           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MarketCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MarketCallerSession struct {
	Contract *MarketCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// MarketTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MarketTransactorSession struct {
	Contract     *MarketTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MarketRaw is an auto generated low-level Go binding around an Ethereum contract.
type MarketRaw struct {
	Contract *Market // Generic contract binding to access the raw methods on
}

// MarketCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MarketCallerRaw struct {
	Contract *MarketCaller // Generic read-only contract binding to access the raw methods on
}

// MarketTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MarketTransactorRaw struct {
	Contract *MarketTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMarket creates a new instance of Market, bound to a specific deployed contract.
func NewMarket(address common.Address, backend bind.ContractBackend) (*Market, error) {
	contract, err := bindMarket(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Market{MarketCaller: MarketCaller{contract: contract}, MarketTransactor: MarketTransactor{contract: contract}, MarketFilterer: MarketFilterer{contract: contract}}, nil
}

// NewMarketCaller creates a new read-only instance of Market, bound to a specific deployed contract.
func NewMarketCaller(address common.Address, caller bind.ContractCaller) (*MarketCaller, error) {
	contract, err := bindMarket(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MarketCaller{contract: contract}, nil
}

// NewMarketTransactor creates a new write-only instance of Market, bound to a specific deployed contract.
func NewMarketTransactor(address common.Address, transactor bind.ContractTransactor) (*MarketTransactor, error) {
	contract, err := bindMarket(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MarketTransactor{contract: contract}, nil
}

// NewMarketFilterer creates a new log filterer instance of Market, bound to a specific deployed contract.
func NewMarketFilterer(address common.Address, filterer bind.ContractFilterer) (*MarketFilterer, error) {
	contract, err := bindMarket(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MarketFilterer{contract: contract}, nil
}

// bindMarket binds a generic wrapper to an already deployed contract.
func bindMarket(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MarketABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Market *MarketRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Market.Contract.MarketCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Market *MarketRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Market.Contract.MarketTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Market *MarketRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Market.Contract.MarketTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Market *MarketCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Market.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Market *MarketTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Market.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Market *MarketTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Market.Contract.contract.Transact(opts, method, params...)
}

// GetChallenge is a free data retrieval call binding the contract method 0x458d2bf1.
//
// Solidity: function getChallenge(hash bytes32) constant returns(out address)
func (_Market *MarketCaller) GetChallenge(opts *bind.CallOpts, hash [32]byte) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getChallenge", hash)
	return *ret0, err
}

// GetChallenge is a free data retrieval call binding the contract method 0x458d2bf1.
//
// Solidity: function getChallenge(hash bytes32) constant returns(out address)
func (_Market *MarketSession) GetChallenge(hash [32]byte) (common.Address, error) {
	return _Market.Contract.GetChallenge(&_Market.CallOpts, hash)
}

// GetChallenge is a free data retrieval call binding the contract method 0x458d2bf1.
//
// Solidity: function getChallenge(hash bytes32) constant returns(out address)
func (_Market *MarketCallerSession) GetChallenge(hash [32]byte) (common.Address, error) {
	return _Market.Contract.GetChallenge(&_Market.CallOpts, hash)
}

// GetDivestmentProceeds is a free data retrieval call binding the contract method 0x99833903.
//
// Solidity: function getDivestmentProceeds(addr address) constant returns(out uint256)
func (_Market *MarketCaller) GetDivestmentProceeds(opts *bind.CallOpts, addr common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getDivestmentProceeds", addr)
	return *ret0, err
}

// GetDivestmentProceeds is a free data retrieval call binding the contract method 0x99833903.
//
// Solidity: function getDivestmentProceeds(addr address) constant returns(out uint256)
func (_Market *MarketSession) GetDivestmentProceeds(addr common.Address) (*big.Int, error) {
	return _Market.Contract.GetDivestmentProceeds(&_Market.CallOpts, addr)
}

// GetDivestmentProceeds is a free data retrieval call binding the contract method 0x99833903.
//
// Solidity: function getDivestmentProceeds(addr address) constant returns(out uint256)
func (_Market *MarketCallerSession) GetDivestmentProceeds(addr common.Address) (*big.Int, error) {
	return _Market.Contract.GetDivestmentProceeds(&_Market.CallOpts, addr)
}

// GetInvested is a free data retrieval call binding the contract method 0xbefc3e2b.
//
// Solidity: function getInvested() constant returns(out uint256)
func (_Market *MarketCaller) GetInvested(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getInvested")
	return *ret0, err
}

// GetInvested is a free data retrieval call binding the contract method 0xbefc3e2b.
//
// Solidity: function getInvested() constant returns(out uint256)
func (_Market *MarketSession) GetInvested() (*big.Int, error) {
	return _Market.Contract.GetInvested(&_Market.CallOpts)
}

// GetInvested is a free data retrieval call binding the contract method 0xbefc3e2b.
//
// Solidity: function getInvested() constant returns(out uint256)
func (_Market *MarketCallerSession) GetInvested() (*big.Int, error) {
	return _Market.Contract.GetInvested(&_Market.CallOpts)
}

// GetInvestment is a free data retrieval call binding the contract method 0x146b58df.
//
// Solidity: function getInvestment(addr address) constant returns(out uint256)
func (_Market *MarketCaller) GetInvestment(opts *bind.CallOpts, addr common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getInvestment", addr)
	return *ret0, err
}

// GetInvestment is a free data retrieval call binding the contract method 0x146b58df.
//
// Solidity: function getInvestment(addr address) constant returns(out uint256)
func (_Market *MarketSession) GetInvestment(addr common.Address) (*big.Int, error) {
	return _Market.Contract.GetInvestment(&_Market.CallOpts, addr)
}

// GetInvestment is a free data retrieval call binding the contract method 0x146b58df.
//
// Solidity: function getInvestment(addr address) constant returns(out uint256)
func (_Market *MarketCallerSession) GetInvestment(addr common.Address) (*big.Int, error) {
	return _Market.Contract.GetInvestment(&_Market.CallOpts, addr)
}

// GetInvestmentPrice is a free data retrieval call binding the contract method 0xa3d6602b.
//
// Solidity: function getInvestmentPrice() constant returns(out uint256)
func (_Market *MarketCaller) GetInvestmentPrice(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getInvestmentPrice")
	return *ret0, err
}

// GetInvestmentPrice is a free data retrieval call binding the contract method 0xa3d6602b.
//
// Solidity: function getInvestmentPrice() constant returns(out uint256)
func (_Market *MarketSession) GetInvestmentPrice() (*big.Int, error) {
	return _Market.Contract.GetInvestmentPrice(&_Market.CallOpts)
}

// GetInvestmentPrice is a free data retrieval call binding the contract method 0xa3d6602b.
//
// Solidity: function getInvestmentPrice() constant returns(out uint256)
func (_Market *MarketCallerSession) GetInvestmentPrice() (*big.Int, error) {
	return _Market.Contract.GetInvestmentPrice(&_Market.CallOpts)
}

// GetInvestorCount is a free data retrieval call binding the contract method 0x960524e3.
//
// Solidity: function getInvestorCount() constant returns(out int128)
func (_Market *MarketCaller) GetInvestorCount(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getInvestorCount")
	return *ret0, err
}

// GetInvestorCount is a free data retrieval call binding the contract method 0x960524e3.
//
// Solidity: function getInvestorCount() constant returns(out int128)
func (_Market *MarketSession) GetInvestorCount() (*big.Int, error) {
	return _Market.Contract.GetInvestorCount(&_Market.CallOpts)
}

// GetInvestorCount is a free data retrieval call binding the contract method 0x960524e3.
//
// Solidity: function getInvestorCount() constant returns(out int128)
func (_Market *MarketCallerSession) GetInvestorCount() (*big.Int, error) {
	return _Market.Contract.GetInvestorCount(&_Market.CallOpts)
}

// GetListing is a free data retrieval call binding the contract method 0x175c0d16.
//
// Solidity: function getListing(hash bytes32) constant returns(out bool, out address, out bytes32, out uint256, out uint256)
func (_Market *MarketCaller) GetListing(opts *bind.CallOpts, hash [32]byte) (bool, common.Address, [32]byte, *big.Int, *big.Int, error) {
	var (
		ret0 = new(bool)
		ret1 = new(common.Address)
		ret2 = new([32]byte)
		ret3 = new(*big.Int)
		ret4 = new(*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
		ret2,
		ret3,
		ret4,
	}
	err := _Market.contract.Call(opts, out, "getListing", hash)
	return *ret0, *ret1, *ret2, *ret3, *ret4, err
}

// GetListing is a free data retrieval call binding the contract method 0x175c0d16.
//
// Solidity: function getListing(hash bytes32) constant returns(out bool, out address, out bytes32, out uint256, out uint256)
func (_Market *MarketSession) GetListing(hash [32]byte) (bool, common.Address, [32]byte, *big.Int, *big.Int, error) {
	return _Market.Contract.GetListing(&_Market.CallOpts, hash)
}

// GetListing is a free data retrieval call binding the contract method 0x175c0d16.
//
// Solidity: function getListing(hash bytes32) constant returns(out bool, out address, out bytes32, out uint256, out uint256)
func (_Market *MarketCallerSession) GetListing(hash [32]byte) (bool, common.Address, [32]byte, *big.Int, *big.Int, error) {
	return _Market.Contract.GetListing(&_Market.CallOpts, hash)
}

// GetListingCount is a free data retrieval call binding the contract method 0x87ed92d7.
//
// Solidity: function getListingCount() constant returns(out int128)
func (_Market *MarketCaller) GetListingCount(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getListingCount")
	return *ret0, err
}

// GetListingCount is a free data retrieval call binding the contract method 0x87ed92d7.
//
// Solidity: function getListingCount() constant returns(out int128)
func (_Market *MarketSession) GetListingCount() (*big.Int, error) {
	return _Market.Contract.GetListingCount(&_Market.CallOpts)
}

// GetListingCount is a free data retrieval call binding the contract method 0x87ed92d7.
//
// Solidity: function getListingCount() constant returns(out int128)
func (_Market *MarketCallerSession) GetListingCount() (*big.Int, error) {
	return _Market.Contract.GetListingCount(&_Market.CallOpts)
}

// GetListingKey is a free data retrieval call binding the contract method 0xc48dc1af.
//
// Solidity: function getListingKey(index int128) constant returns(out bytes32)
func (_Market *MarketCaller) GetListingKey(opts *bind.CallOpts, index *big.Int) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "getListingKey", index)
	return *ret0, err
}

// GetListingKey is a free data retrieval call binding the contract method 0xc48dc1af.
//
// Solidity: function getListingKey(index int128) constant returns(out bytes32)
func (_Market *MarketSession) GetListingKey(index *big.Int) ([32]byte, error) {
	return _Market.Contract.GetListingKey(&_Market.CallOpts, index)
}

// GetListingKey is a free data retrieval call binding the contract method 0xc48dc1af.
//
// Solidity: function getListingKey(index int128) constant returns(out bytes32)
func (_Market *MarketCallerSession) GetListingKey(index *big.Int) ([32]byte, error) {
	return _Market.Contract.GetListingKey(&_Market.CallOpts, index)
}

// IsInvestor is a free data retrieval call binding the contract method 0xcee2a9cf.
//
// Solidity: function isInvestor(addr address) constant returns(out bool)
func (_Market *MarketCaller) IsInvestor(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "isInvestor", addr)
	return *ret0, err
}

// IsInvestor is a free data retrieval call binding the contract method 0xcee2a9cf.
//
// Solidity: function isInvestor(addr address) constant returns(out bool)
func (_Market *MarketSession) IsInvestor(addr common.Address) (bool, error) {
	return _Market.Contract.IsInvestor(&_Market.CallOpts, addr)
}

// IsInvestor is a free data retrieval call binding the contract method 0xcee2a9cf.
//
// Solidity: function isInvestor(addr address) constant returns(out bool)
func (_Market *MarketCallerSession) IsInvestor(addr common.Address) (bool, error) {
	return _Market.Contract.IsInvestor(&_Market.CallOpts, addr)
}

// IsListed is a free data retrieval call binding the contract method 0xecefbdc6.
//
// Solidity: function isListed(hash bytes32) constant returns(out bool)
func (_Market *MarketCaller) IsListed(opts *bind.CallOpts, hash [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "isListed", hash)
	return *ret0, err
}

// IsListed is a free data retrieval call binding the contract method 0xecefbdc6.
//
// Solidity: function isListed(hash bytes32) constant returns(out bool)
func (_Market *MarketSession) IsListed(hash [32]byte) (bool, error) {
	return _Market.Contract.IsListed(&_Market.CallOpts, hash)
}

// IsListed is a free data retrieval call binding the contract method 0xecefbdc6.
//
// Solidity: function isListed(hash bytes32) constant returns(out bool)
func (_Market *MarketCallerSession) IsListed(hash [32]byte) (bool, error) {
	return _Market.Contract.IsListed(&_Market.CallOpts, hash)
}

// IsListing is a free data retrieval call binding the contract method 0x6aa0966b.
//
// Solidity: function isListing(hash bytes32) constant returns(out bool)
func (_Market *MarketCaller) IsListing(opts *bind.CallOpts, hash [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "isListing", hash)
	return *ret0, err
}

// IsListing is a free data retrieval call binding the contract method 0x6aa0966b.
//
// Solidity: function isListing(hash bytes32) constant returns(out bool)
func (_Market *MarketSession) IsListing(hash [32]byte) (bool, error) {
	return _Market.Contract.IsListing(&_Market.CallOpts, hash)
}

// IsListing is a free data retrieval call binding the contract method 0x6aa0966b.
//
// Solidity: function isListing(hash bytes32) constant returns(out bool)
func (_Market *MarketCallerSession) IsListing(hash [32]byte) (bool, error) {
	return _Market.Contract.IsListing(&_Market.CallOpts, hash)
}

// IsListingOwner is a free data retrieval call binding the contract method 0x02a47cd7.
//
// Solidity: function isListingOwner(addr address) constant returns(out bool)
func (_Market *MarketCaller) IsListingOwner(opts *bind.CallOpts, addr common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "isListingOwner", addr)
	return *ret0, err
}

// IsListingOwner is a free data retrieval call binding the contract method 0x02a47cd7.
//
// Solidity: function isListingOwner(addr address) constant returns(out bool)
func (_Market *MarketSession) IsListingOwner(addr common.Address) (bool, error) {
	return _Market.Contract.IsListingOwner(&_Market.CallOpts, addr)
}

// IsListingOwner is a free data retrieval call binding the contract method 0x02a47cd7.
//
// Solidity: function isListingOwner(addr address) constant returns(out bool)
func (_Market *MarketCallerSession) IsListingOwner(addr common.Address) (bool, error) {
	return _Market.Contract.IsListingOwner(&_Market.CallOpts, addr)
}

// WasListing is a free data retrieval call binding the contract method 0x82c3eb3e.
//
// Solidity: function wasListing(hash bytes32) constant returns(out bool)
func (_Market *MarketCaller) WasListing(opts *bind.CallOpts, hash [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Market.contract.Call(opts, out, "wasListing", hash)
	return *ret0, err
}

// WasListing is a free data retrieval call binding the contract method 0x82c3eb3e.
//
// Solidity: function wasListing(hash bytes32) constant returns(out bool)
func (_Market *MarketSession) WasListing(hash [32]byte) (bool, error) {
	return _Market.Contract.WasListing(&_Market.CallOpts, hash)
}

// WasListing is a free data retrieval call binding the contract method 0x82c3eb3e.
//
// Solidity: function wasListing(hash bytes32) constant returns(out bool)
func (_Market *MarketCallerSession) WasListing(hash [32]byte) (bool, error) {
	return _Market.Contract.WasListing(&_Market.CallOpts, hash)
}

// Challenge is a paid mutator transaction binding the contract method 0xcd32dcc5.
//
// Solidity: function challenge(chall string, hash bytes32) returns()
func (_Market *MarketTransactor) Challenge(opts *bind.TransactOpts, chall string, hash [32]byte) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "challenge", chall, hash)
}

// Challenge is a paid mutator transaction binding the contract method 0xcd32dcc5.
//
// Solidity: function challenge(chall string, hash bytes32) returns()
func (_Market *MarketSession) Challenge(chall string, hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.Challenge(&_Market.TransactOpts, chall, hash)
}

// Challenge is a paid mutator transaction binding the contract method 0xcd32dcc5.
//
// Solidity: function challenge(chall string, hash bytes32) returns()
func (_Market *MarketTransactorSession) Challenge(chall string, hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.Challenge(&_Market.TransactOpts, chall, hash)
}

// ConvertListing is a paid mutator transaction binding the contract method 0xd748484d.
//
// Solidity: function convertListing(hash bytes32) returns()
func (_Market *MarketTransactor) ConvertListing(opts *bind.TransactOpts, hash [32]byte) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "convertListing", hash)
}

// ConvertListing is a paid mutator transaction binding the contract method 0xd748484d.
//
// Solidity: function convertListing(hash bytes32) returns()
func (_Market *MarketSession) ConvertListing(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.ConvertListing(&_Market.TransactOpts, hash)
}

// ConvertListing is a paid mutator transaction binding the contract method 0xd748484d.
//
// Solidity: function convertListing(hash bytes32) returns()
func (_Market *MarketTransactorSession) ConvertListing(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.ConvertListing(&_Market.TransactOpts, hash)
}

// DepositToListing is a paid mutator transaction binding the contract method 0x341ff089.
//
// Solidity: function depositToListing(hash bytes32, amount uint256) returns()
func (_Market *MarketTransactor) DepositToListing(opts *bind.TransactOpts, hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "depositToListing", hash, amount)
}

// DepositToListing is a paid mutator transaction binding the contract method 0x341ff089.
//
// Solidity: function depositToListing(hash bytes32, amount uint256) returns()
func (_Market *MarketSession) DepositToListing(hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.Contract.DepositToListing(&_Market.TransactOpts, hash, amount)
}

// DepositToListing is a paid mutator transaction binding the contract method 0x341ff089.
//
// Solidity: function depositToListing(hash bytes32, amount uint256) returns()
func (_Market *MarketTransactorSession) DepositToListing(hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.Contract.DepositToListing(&_Market.TransactOpts, hash, amount)
}

// Divest is a paid mutator transaction binding the contract method 0x058aace1.
//
// Solidity: function divest() returns()
func (_Market *MarketTransactor) Divest(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "divest")
}

// Divest is a paid mutator transaction binding the contract method 0x058aace1.
//
// Solidity: function divest() returns()
func (_Market *MarketSession) Divest() (*types.Transaction, error) {
	return _Market.Contract.Divest(&_Market.TransactOpts)
}

// Divest is a paid mutator transaction binding the contract method 0x058aace1.
//
// Solidity: function divest() returns()
func (_Market *MarketTransactorSession) Divest() (*types.Transaction, error) {
	return _Market.Contract.Divest(&_Market.TransactOpts)
}

// Exit is a paid mutator transaction binding the contract method 0x0ca36263.
//
// Solidity: function exit(hash bytes32) returns()
func (_Market *MarketTransactor) Exit(opts *bind.TransactOpts, hash [32]byte) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "exit", hash)
}

// Exit is a paid mutator transaction binding the contract method 0x0ca36263.
//
// Solidity: function exit(hash bytes32) returns()
func (_Market *MarketSession) Exit(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.Exit(&_Market.TransactOpts, hash)
}

// Exit is a paid mutator transaction binding the contract method 0x0ca36263.
//
// Solidity: function exit(hash bytes32) returns()
func (_Market *MarketTransactorSession) Exit(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.Exit(&_Market.TransactOpts, hash)
}

// Invest is a paid mutator transaction binding the contract method 0x2afcf480.
//
// Solidity: function invest(offer uint256) returns()
func (_Market *MarketTransactor) Invest(opts *bind.TransactOpts, offer *big.Int) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "invest", offer)
}

// Invest is a paid mutator transaction binding the contract method 0x2afcf480.
//
// Solidity: function invest(offer uint256) returns()
func (_Market *MarketSession) Invest(offer *big.Int) (*types.Transaction, error) {
	return _Market.Contract.Invest(&_Market.TransactOpts, offer)
}

// Invest is a paid mutator transaction binding the contract method 0x2afcf480.
//
// Solidity: function invest(offer uint256) returns()
func (_Market *MarketTransactorSession) Invest(offer *big.Int) (*types.Transaction, error) {
	return _Market.Contract.Invest(&_Market.TransactOpts, offer)
}

// List is a paid mutator transaction binding the contract method 0x5148cd0f.
//
// Solidity: function list(listing string, data_hash bytes32, amount uint256) returns()
func (_Market *MarketTransactor) List(opts *bind.TransactOpts, listing string, data_hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "list", listing, data_hash, amount)
}

// List is a paid mutator transaction binding the contract method 0x5148cd0f.
//
// Solidity: function list(listing string, data_hash bytes32, amount uint256) returns()
func (_Market *MarketSession) List(listing string, data_hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.Contract.List(&_Market.TransactOpts, listing, data_hash, amount)
}

// List is a paid mutator transaction binding the contract method 0x5148cd0f.
//
// Solidity: function list(listing string, data_hash bytes32, amount uint256) returns()
func (_Market *MarketTransactorSession) List(listing string, data_hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.Contract.List(&_Market.TransactOpts, listing, data_hash, amount)
}

// ResolveApplication is a paid mutator transaction binding the contract method 0x18e28e1c.
//
// Solidity: function resolveApplication(hash bytes32) returns()
func (_Market *MarketTransactor) ResolveApplication(opts *bind.TransactOpts, hash [32]byte) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "resolveApplication", hash)
}

// ResolveApplication is a paid mutator transaction binding the contract method 0x18e28e1c.
//
// Solidity: function resolveApplication(hash bytes32) returns()
func (_Market *MarketSession) ResolveApplication(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.ResolveApplication(&_Market.TransactOpts, hash)
}

// ResolveApplication is a paid mutator transaction binding the contract method 0x18e28e1c.
//
// Solidity: function resolveApplication(hash bytes32) returns()
func (_Market *MarketTransactorSession) ResolveApplication(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.ResolveApplication(&_Market.TransactOpts, hash)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0xd32c943a.
//
// Solidity: function resolveChallenge(hash bytes32) returns()
func (_Market *MarketTransactor) ResolveChallenge(opts *bind.TransactOpts, hash [32]byte) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "resolveChallenge", hash)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0xd32c943a.
//
// Solidity: function resolveChallenge(hash bytes32) returns()
func (_Market *MarketSession) ResolveChallenge(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.ResolveChallenge(&_Market.TransactOpts, hash)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0xd32c943a.
//
// Solidity: function resolveChallenge(hash bytes32) returns()
func (_Market *MarketTransactorSession) ResolveChallenge(hash [32]byte) (*types.Transaction, error) {
	return _Market.Contract.ResolveChallenge(&_Market.TransactOpts, hash)
}

// WithdrawFromListing is a paid mutator transaction binding the contract method 0xa7e78675.
//
// Solidity: function withdrawFromListing(hash bytes32, amount uint256) returns()
func (_Market *MarketTransactor) WithdrawFromListing(opts *bind.TransactOpts, hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.contract.Transact(opts, "withdrawFromListing", hash, amount)
}

// WithdrawFromListing is a paid mutator transaction binding the contract method 0xa7e78675.
//
// Solidity: function withdrawFromListing(hash bytes32, amount uint256) returns()
func (_Market *MarketSession) WithdrawFromListing(hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.Contract.WithdrawFromListing(&_Market.TransactOpts, hash, amount)
}

// WithdrawFromListing is a paid mutator transaction binding the contract method 0xa7e78675.
//
// Solidity: function withdrawFromListing(hash bytes32, amount uint256) returns()
func (_Market *MarketTransactorSession) WithdrawFromListing(hash [32]byte, amount *big.Int) (*types.Transaction, error) {
	return _Market.Contract.WithdrawFromListing(&_Market.TransactOpts, hash, amount)
}

// MarketApplicationFailedIterator is returned from FilterApplicationFailed and is used to iterate over the raw logs and unpacked data for ApplicationFailed events raised by the Market contract.
type MarketApplicationFailedIterator struct {
	Event *MarketApplicationFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketApplicationFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketApplicationFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketApplicationFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketApplicationFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketApplicationFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketApplicationFailed represents a ApplicationFailed event raised by the Market contract.
type MarketApplicationFailed struct {
	Hash [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterApplicationFailed is a free log retrieval operation binding the contract event 0x1e766ffad15a98a0dfb403123edc5f30e83e4981b1799b32a2cec29468fc84fd.
//
// Solidity: e ApplicationFailed(hash indexed bytes32)
func (_Market *MarketFilterer) FilterApplicationFailed(opts *bind.FilterOpts, hash [][32]byte) (*MarketApplicationFailedIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "ApplicationFailed", hashRule)
	if err != nil {
		return nil, err
	}
	return &MarketApplicationFailedIterator{contract: _Market.contract, event: "ApplicationFailed", logs: logs, sub: sub}, nil
}

// WatchApplicationFailed is a free log subscription operation binding the contract event 0x1e766ffad15a98a0dfb403123edc5f30e83e4981b1799b32a2cec29468fc84fd.
//
// Solidity: e ApplicationFailed(hash indexed bytes32)
func (_Market *MarketFilterer) WatchApplicationFailed(opts *bind.WatchOpts, sink chan<- *MarketApplicationFailed, hash [][32]byte) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "ApplicationFailed", hashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketApplicationFailed)
				if err := _Market.contract.UnpackLog(event, "ApplicationFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketAppliedIterator is returned from FilterApplied and is used to iterate over the raw logs and unpacked data for Applied events raised by the Market contract.
type MarketAppliedIterator struct {
	Event *MarketApplied // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketAppliedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketApplied)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketApplied)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketAppliedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketAppliedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketApplied represents a Applied event raised by the Market contract.
type MarketApplied struct {
	Hash      [32]byte
	Applicant common.Address
	DataHash  [32]byte
	Amount    *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterApplied is a free log retrieval operation binding the contract event 0x2be7f407f8117561d2a0100982c56a4a1ec8ffc24bbeb7b087b2ca8a224cc56d.
//
// Solidity: e Applied(hash indexed bytes32, applicant indexed address, dataHash bytes32, amount uint256)
func (_Market *MarketFilterer) FilterApplied(opts *bind.FilterOpts, hash [][32]byte, applicant []common.Address) (*MarketAppliedIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var applicantRule []interface{}
	for _, applicantItem := range applicant {
		applicantRule = append(applicantRule, applicantItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "Applied", hashRule, applicantRule)
	if err != nil {
		return nil, err
	}
	return &MarketAppliedIterator{contract: _Market.contract, event: "Applied", logs: logs, sub: sub}, nil
}

// WatchApplied is a free log subscription operation binding the contract event 0x2be7f407f8117561d2a0100982c56a4a1ec8ffc24bbeb7b087b2ca8a224cc56d.
//
// Solidity: e Applied(hash indexed bytes32, applicant indexed address, dataHash bytes32, amount uint256)
func (_Market *MarketFilterer) WatchApplied(opts *bind.WatchOpts, sink chan<- *MarketApplied, hash [][32]byte, applicant []common.Address) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var applicantRule []interface{}
	for _, applicantItem := range applicant {
		applicantRule = append(applicantRule, applicantItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "Applied", hashRule, applicantRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketApplied)
				if err := _Market.contract.UnpackLog(event, "Applied", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketChallengeFailedIterator is returned from FilterChallengeFailed and is used to iterate over the raw logs and unpacked data for ChallengeFailed events raised by the Market contract.
type MarketChallengeFailedIterator struct {
	Event *MarketChallengeFailed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketChallengeFailedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketChallengeFailed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketChallengeFailed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketChallengeFailedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketChallengeFailedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketChallengeFailed represents a ChallengeFailed event raised by the Market contract.
type MarketChallengeFailed struct {
	Hash       [32]byte
	Challenger common.Address
	Reward     *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterChallengeFailed is a free log retrieval operation binding the contract event 0xc7aab91fe7b50a881bd71df2cf07e9a6e5351721087cdb09bc70603f618e7057.
//
// Solidity: e ChallengeFailed(hash indexed bytes32, challenger indexed address, reward uint256)
func (_Market *MarketFilterer) FilterChallengeFailed(opts *bind.FilterOpts, hash [][32]byte, challenger []common.Address) (*MarketChallengeFailedIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "ChallengeFailed", hashRule, challengerRule)
	if err != nil {
		return nil, err
	}
	return &MarketChallengeFailedIterator{contract: _Market.contract, event: "ChallengeFailed", logs: logs, sub: sub}, nil
}

// WatchChallengeFailed is a free log subscription operation binding the contract event 0xc7aab91fe7b50a881bd71df2cf07e9a6e5351721087cdb09bc70603f618e7057.
//
// Solidity: e ChallengeFailed(hash indexed bytes32, challenger indexed address, reward uint256)
func (_Market *MarketFilterer) WatchChallengeFailed(opts *bind.WatchOpts, sink chan<- *MarketChallengeFailed, hash [][32]byte, challenger []common.Address) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "ChallengeFailed", hashRule, challengerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketChallengeFailed)
				if err := _Market.contract.UnpackLog(event, "ChallengeFailed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketChallengeSucceededIterator is returned from FilterChallengeSucceeded and is used to iterate over the raw logs and unpacked data for ChallengeSucceeded events raised by the Market contract.
type MarketChallengeSucceededIterator struct {
	Event *MarketChallengeSucceeded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketChallengeSucceededIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketChallengeSucceeded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketChallengeSucceeded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketChallengeSucceededIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketChallengeSucceededIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketChallengeSucceeded represents a ChallengeSucceeded event raised by the Market contract.
type MarketChallengeSucceeded struct {
	Hash       [32]byte
	Challenger common.Address
	Reward     *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterChallengeSucceeded is a free log retrieval operation binding the contract event 0xb2432a6d7681dc3f7416efc0e321723b96bd7a96d2d02d228dc2a67c51cf0322.
//
// Solidity: e ChallengeSucceeded(hash indexed bytes32, challenger indexed address, reward uint256)
func (_Market *MarketFilterer) FilterChallengeSucceeded(opts *bind.FilterOpts, hash [][32]byte, challenger []common.Address) (*MarketChallengeSucceededIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "ChallengeSucceeded", hashRule, challengerRule)
	if err != nil {
		return nil, err
	}
	return &MarketChallengeSucceededIterator{contract: _Market.contract, event: "ChallengeSucceeded", logs: logs, sub: sub}, nil
}

// WatchChallengeSucceeded is a free log subscription operation binding the contract event 0xb2432a6d7681dc3f7416efc0e321723b96bd7a96d2d02d228dc2a67c51cf0322.
//
// Solidity: e ChallengeSucceeded(hash indexed bytes32, challenger indexed address, reward uint256)
func (_Market *MarketFilterer) WatchChallengeSucceeded(opts *bind.WatchOpts, sink chan<- *MarketChallengeSucceeded, hash [][32]byte, challenger []common.Address) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "ChallengeSucceeded", hashRule, challengerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketChallengeSucceeded)
				if err := _Market.contract.UnpackLog(event, "ChallengeSucceeded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketChallengedIterator is returned from FilterChallenged and is used to iterate over the raw logs and unpacked data for Challenged events raised by the Market contract.
type MarketChallengedIterator struct {
	Event *MarketChallenged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketChallengedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketChallenged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketChallenged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketChallengedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketChallengedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketChallenged represents a Challenged event raised by the Market contract.
type MarketChallenged struct {
	Hash       [32]byte
	Challenger common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterChallenged is a free log retrieval operation binding the contract event 0xe9479421670c3425a1497ce47a53af8bd96ce5bd0741e96221ba0acace3f7d47.
//
// Solidity: e Challenged(hash indexed bytes32, challenger indexed address)
func (_Market *MarketFilterer) FilterChallenged(opts *bind.FilterOpts, hash [][32]byte, challenger []common.Address) (*MarketChallengedIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "Challenged", hashRule, challengerRule)
	if err != nil {
		return nil, err
	}
	return &MarketChallengedIterator{contract: _Market.contract, event: "Challenged", logs: logs, sub: sub}, nil
}

// WatchChallenged is a free log subscription operation binding the contract event 0xe9479421670c3425a1497ce47a53af8bd96ce5bd0741e96221ba0acace3f7d47.
//
// Solidity: e Challenged(hash indexed bytes32, challenger indexed address)
func (_Market *MarketFilterer) WatchChallenged(opts *bind.WatchOpts, sink chan<- *MarketChallenged, hash [][32]byte, challenger []common.Address) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var challengerRule []interface{}
	for _, challengerItem := range challenger {
		challengerRule = append(challengerRule, challengerItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "Challenged", hashRule, challengerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketChallenged)
				if err := _Market.contract.UnpackLog(event, "Challenged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketDivestedIterator is returned from FilterDivested and is used to iterate over the raw logs and unpacked data for Divested events raised by the Market contract.
type MarketDivestedIterator struct {
	Event *MarketDivested // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketDivestedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketDivested)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketDivested)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketDivestedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketDivestedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketDivested represents a Divested event raised by the Market contract.
type MarketDivested struct {
	Investor    common.Address
	Transferred *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDivested is a free log retrieval operation binding the contract event 0x2253aebe2fe8682635bbe60d9b78df72efaf785a596910a8ad66e8c6e37584fd.
//
// Solidity: e Divested(investor indexed address, transferred uint256)
func (_Market *MarketFilterer) FilterDivested(opts *bind.FilterOpts, investor []common.Address) (*MarketDivestedIterator, error) {

	var investorRule []interface{}
	for _, investorItem := range investor {
		investorRule = append(investorRule, investorItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "Divested", investorRule)
	if err != nil {
		return nil, err
	}
	return &MarketDivestedIterator{contract: _Market.contract, event: "Divested", logs: logs, sub: sub}, nil
}

// WatchDivested is a free log subscription operation binding the contract event 0x2253aebe2fe8682635bbe60d9b78df72efaf785a596910a8ad66e8c6e37584fd.
//
// Solidity: e Divested(investor indexed address, transferred uint256)
func (_Market *MarketFilterer) WatchDivested(opts *bind.WatchOpts, sink chan<- *MarketDivested, investor []common.Address) (event.Subscription, error) {

	var investorRule []interface{}
	for _, investorItem := range investor {
		investorRule = append(investorRule, investorItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "Divested", investorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketDivested)
				if err := _Market.contract.UnpackLog(event, "Divested", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketInvestedIterator is returned from FilterInvested and is used to iterate over the raw logs and unpacked data for Invested events raised by the Market contract.
type MarketInvestedIterator struct {
	Event *MarketInvested // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketInvestedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketInvested)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketInvested)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketInvestedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketInvestedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketInvested represents a Invested event raised by the Market contract.
type MarketInvested struct {
	Investor common.Address
	Offered  *big.Int
	Minted   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterInvested is a free log retrieval operation binding the contract event 0x9e9d071824fd57d062ca63fd8b786d8da48a6807eebbcb2d83f9e8d21398e28c.
//
// Solidity: e Invested(investor indexed address, offered uint256, minted uint256)
func (_Market *MarketFilterer) FilterInvested(opts *bind.FilterOpts, investor []common.Address) (*MarketInvestedIterator, error) {

	var investorRule []interface{}
	for _, investorItem := range investor {
		investorRule = append(investorRule, investorItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "Invested", investorRule)
	if err != nil {
		return nil, err
	}
	return &MarketInvestedIterator{contract: _Market.contract, event: "Invested", logs: logs, sub: sub}, nil
}

// WatchInvested is a free log subscription operation binding the contract event 0x9e9d071824fd57d062ca63fd8b786d8da48a6807eebbcb2d83f9e8d21398e28c.
//
// Solidity: e Invested(investor indexed address, offered uint256, minted uint256)
func (_Market *MarketFilterer) WatchInvested(opts *bind.WatchOpts, sink chan<- *MarketInvested, investor []common.Address) (event.Subscription, error) {

	var investorRule []interface{}
	for _, investorItem := range investor {
		investorRule = append(investorRule, investorItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "Invested", investorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketInvested)
				if err := _Market.contract.UnpackLog(event, "Invested", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketListedIterator is returned from FilterListed and is used to iterate over the raw logs and unpacked data for Listed events raised by the Market contract.
type MarketListedIterator struct {
	Event *MarketListed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketListedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketListed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketListed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketListedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketListedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketListed represents a Listed event raised by the Market contract.
type MarketListed struct {
	Hash   [32]byte
	Owner  common.Address
	Reward *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterListed is a free log retrieval operation binding the contract event 0x7f1a2c3e2883554425dc0f9f24dcfcdf54213b186c550080373dcc65813aa8d0.
//
// Solidity: e Listed(hash indexed bytes32, owner indexed address, reward uint256)
func (_Market *MarketFilterer) FilterListed(opts *bind.FilterOpts, hash [][32]byte, owner []common.Address) (*MarketListedIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "Listed", hashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return &MarketListedIterator{contract: _Market.contract, event: "Listed", logs: logs, sub: sub}, nil
}

// WatchListed is a free log subscription operation binding the contract event 0x7f1a2c3e2883554425dc0f9f24dcfcdf54213b186c550080373dcc65813aa8d0.
//
// Solidity: e Listed(hash indexed bytes32, owner indexed address, reward uint256)
func (_Market *MarketFilterer) WatchListed(opts *bind.WatchOpts, sink chan<- *MarketListed, hash [][32]byte, owner []common.Address) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "Listed", hashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketListed)
				if err := _Market.contract.UnpackLog(event, "Listed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketListingConvertedIterator is returned from FilterListingConverted and is used to iterate over the raw logs and unpacked data for ListingConverted events raised by the Market contract.
type MarketListingConvertedIterator struct {
	Event *MarketListingConverted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketListingConvertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketListingConverted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketListingConverted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketListingConvertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketListingConvertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketListingConverted represents a ListingConverted event raised by the Market contract.
type MarketListingConverted struct {
	Hash [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterListingConverted is a free log retrieval operation binding the contract event 0xfd6a9ca1840ac9f8b7c592783e5415fdc282281630286c93b07b6d40f3c0ba57.
//
// Solidity: e ListingConverted(hash indexed bytes32)
func (_Market *MarketFilterer) FilterListingConverted(opts *bind.FilterOpts, hash [][32]byte) (*MarketListingConvertedIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "ListingConverted", hashRule)
	if err != nil {
		return nil, err
	}
	return &MarketListingConvertedIterator{contract: _Market.contract, event: "ListingConverted", logs: logs, sub: sub}, nil
}

// WatchListingConverted is a free log subscription operation binding the contract event 0xfd6a9ca1840ac9f8b7c592783e5415fdc282281630286c93b07b6d40f3c0ba57.
//
// Solidity: e ListingConverted(hash indexed bytes32)
func (_Market *MarketFilterer) WatchListingConverted(opts *bind.WatchOpts, sink chan<- *MarketListingConverted, hash [][32]byte) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "ListingConverted", hashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketListingConverted)
				if err := _Market.contract.UnpackLog(event, "ListingConverted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketListingDepositIterator is returned from FilterListingDeposit and is used to iterate over the raw logs and unpacked data for ListingDeposit events raised by the Market contract.
type MarketListingDepositIterator struct {
	Event *MarketListingDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketListingDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketListingDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketListingDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketListingDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketListingDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketListingDeposit represents a ListingDeposit event raised by the Market contract.
type MarketListingDeposit struct {
	Hash      [32]byte
	Owner     common.Address
	Deposited *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterListingDeposit is a free log retrieval operation binding the contract event 0x6f27446a1e23c7e7dd81a6a77f81438be78145de331a5806f2c44e68738bdcef.
//
// Solidity: e ListingDeposit(hash indexed bytes32, owner indexed address, deposited uint256)
func (_Market *MarketFilterer) FilterListingDeposit(opts *bind.FilterOpts, hash [][32]byte, owner []common.Address) (*MarketListingDepositIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "ListingDeposit", hashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return &MarketListingDepositIterator{contract: _Market.contract, event: "ListingDeposit", logs: logs, sub: sub}, nil
}

// WatchListingDeposit is a free log subscription operation binding the contract event 0x6f27446a1e23c7e7dd81a6a77f81438be78145de331a5806f2c44e68738bdcef.
//
// Solidity: e ListingDeposit(hash indexed bytes32, owner indexed address, deposited uint256)
func (_Market *MarketFilterer) WatchListingDeposit(opts *bind.WatchOpts, sink chan<- *MarketListingDeposit, hash [][32]byte, owner []common.Address) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "ListingDeposit", hashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketListingDeposit)
				if err := _Market.contract.UnpackLog(event, "ListingDeposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketListingRemovedIterator is returned from FilterListingRemoved and is used to iterate over the raw logs and unpacked data for ListingRemoved events raised by the Market contract.
type MarketListingRemovedIterator struct {
	Event *MarketListingRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketListingRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketListingRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketListingRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketListingRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketListingRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketListingRemoved represents a ListingRemoved event raised by the Market contract.
type MarketListingRemoved struct {
	Hash [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterListingRemoved is a free log retrieval operation binding the contract event 0x50425cae216bd151d26c8e8bb9779cc899c99d72f78081f2ceec9a99f001ff79.
//
// Solidity: e ListingRemoved(hash indexed bytes32)
func (_Market *MarketFilterer) FilterListingRemoved(opts *bind.FilterOpts, hash [][32]byte) (*MarketListingRemovedIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "ListingRemoved", hashRule)
	if err != nil {
		return nil, err
	}
	return &MarketListingRemovedIterator{contract: _Market.contract, event: "ListingRemoved", logs: logs, sub: sub}, nil
}

// WatchListingRemoved is a free log subscription operation binding the contract event 0x50425cae216bd151d26c8e8bb9779cc899c99d72f78081f2ceec9a99f001ff79.
//
// Solidity: e ListingRemoved(hash indexed bytes32)
func (_Market *MarketFilterer) WatchListingRemoved(opts *bind.WatchOpts, sink chan<- *MarketListingRemoved, hash [][32]byte) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "ListingRemoved", hashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketListingRemoved)
				if err := _Market.contract.UnpackLog(event, "ListingRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MarketListingWithdrawIterator is returned from FilterListingWithdraw and is used to iterate over the raw logs and unpacked data for ListingWithdraw events raised by the Market contract.
type MarketListingWithdrawIterator struct {
	Event *MarketListingWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MarketListingWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MarketListingWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MarketListingWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MarketListingWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MarketListingWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MarketListingWithdraw represents a ListingWithdraw event raised by the Market contract.
type MarketListingWithdraw struct {
	Hash      [32]byte
	Owner     common.Address
	Withdrawn *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterListingWithdraw is a free log retrieval operation binding the contract event 0x87c48f853a68e9374cf8389dab199f46adaffa48468fe9a4e2dc2edf75286db7.
//
// Solidity: e ListingWithdraw(hash indexed bytes32, owner indexed address, withdrawn uint256)
func (_Market *MarketFilterer) FilterListingWithdraw(opts *bind.FilterOpts, hash [][32]byte, owner []common.Address) (*MarketListingWithdrawIterator, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Market.contract.FilterLogs(opts, "ListingWithdraw", hashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return &MarketListingWithdrawIterator{contract: _Market.contract, event: "ListingWithdraw", logs: logs, sub: sub}, nil
}

// WatchListingWithdraw is a free log subscription operation binding the contract event 0x87c48f853a68e9374cf8389dab199f46adaffa48468fe9a4e2dc2edf75286db7.
//
// Solidity: e ListingWithdraw(hash indexed bytes32, owner indexed address, withdrawn uint256)
func (_Market *MarketFilterer) WatchListingWithdraw(opts *bind.WatchOpts, sink chan<- *MarketListingWithdraw, hash [][32]byte, owner []common.Address) (event.Subscription, error) {

	var hashRule []interface{}
	for _, hashItem := range hash {
		hashRule = append(hashRule, hashItem)
	}
	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Market.contract.WatchLogs(opts, "ListingWithdraw", hashRule, ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MarketListingWithdraw)
				if err := _Market.contract.UnpackLog(event, "ListingWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}
